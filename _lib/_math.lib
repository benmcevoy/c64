#importonce
#import "_prelude.lib"

.namespace Math {

    /* Pi in BRADs */
    .const PI = 128
    .const TWOPI = 128
    .const HALFPI = 64

    // I'm using x86 namings here mul, smul etc.

    // Mul: {
    //     // TODO:
    //     rts
    // }

    // SMul: {
    //     // TODO:
    //     rts
    // }

    /* 
    Multiply two unsigned 8 bit numbers, 16 bit unsigned result in __val0 (LO),__val1 (HI)
    From: https://llx.com/Neil/a2/mult.html
     */
    Mul16: {
        .var op1 = __arg0
        .var op2 = __arg1

        Set __val0:#0

        lda #0       // initialize result to 0
        ldx #8       // there are 8 bits in num2
l1:     lsr op2      // get low bit of num2
        bcc l2       // 0 or 1?
        clc          // if 1, add num1
        adc op1
l2:     ror          // "stairstep" shift (catching carry from add)
        ror __val0
        dex
        bne l1
        sta __val1

        rts
    }

    /*
    Multiply two signed bytes, returning a signed 16 result in __val0 (LO),__val1 (HI)
    */
    SMul16: {
        .var op1 = __arg0
        .var op2 = __arg1

        // a * -b is the same as -( a * b )
        // compute the sign first, then make positive and call Mul16
        // then apply the sign

        // if the MSB on EITHER operand is high, exclusively, e.g. XOR
        // then negative, if both high or both low then positive result

        // in the example from the the Mul16 above they php the processor flags, which has N,Z
        // instead I store it in __tmp0 as I am not that smart

        Set __tmp0:#0

        lda op1
        and #128
        cmp #128
        bne !+
            Negate(op1)
            inc __tmp0
        !:

        lda op2
        and #128
        cmp #128
        bne !+
            Negate(op2)
            inc __tmp0
        !:

        Call Mul16:op1:op2

        // set sign of result __val0 __val1
        // here they pull the processor flags back off the stack
        // and do a BPL against the N flag, maybe they save a few cycles but it bends my brain...
        lda __tmp0
        cmp #1
        bne !+
            Negate16(__val0, __val1)
        !:

        rts
    }


    Add16: {
        .var op1Lo = __arg0
        .var op1Hi = __arg1
        .var op2Lo = __arg2
        .var op2Hi = __arg3

        lda op1Lo
        clc
        adc op2Lo
        sta __val0
        lda op1Hi
        adc op2Hi
        sta __val1
        
        rts
    }
}

    // can't have a macro in a namespace?

    // .macro Add16 (op1Lo, op1Hi, op2Lo, op2Hi) {
    //     lda op1Lo
    //     clc
    //     adc op2Lo
    //     sta __val0
    //     lda op1Hi
    //     adc op2Hi
    //     sta __val1
    // }

    .macro Sub16 (op1Lo, op1Hi, op2Lo, op2Hi) {
        lda op1Lo
        sec
        sbc op2Lo
        sta __val0
        lda op1Hi
        sbc op2Hi
        sta __val1
    }