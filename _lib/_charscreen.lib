#importonce
#import "_prelude.lib"
#import "_debug.lib"

.namespace CharScreen {
    Character: .byte 204
    PenColor: .byte GREEN

    // TODO: yikes, pretty terrible. probably should queue the shake as part of the render
    Shake: {
        .label xScroll = $d016

        ldx #0
        ldy #0
    shake:
        Set offset:#8
    loop:    

        Set xScroll:offset
        ldx #0
        delay:
        dex
        cpx #0
        bne delay

        iny
        cpy #16
        beq exit

        inc offset
        lda offset
        cmp #16
        beq shake
        jmp loop
    exit:
        Set xScroll:#8
        rts

        offset: .byte 0
    }
    
    /* Write a string to x,y */
    // TODO: kind of awkward, not able to pass an address, only values?
    WriteString: {
        .var x = __arg0
        .var y = __arg1
        .var textL = __arg2
        .var textH = __arg3
            
        Push CharScreen.Character

        Set __ptr0:textL
        Set __ptr0+1:textH

        Set xWrite:x
        
        ldy #0
        loop:   
            lda (__ptr0),y
            cmp #ACTION_HANDLED
            beq exit
            sta  CharScreen.Character
            Call  CharScreen.Plot:xWrite:y
            inc xWrite
            iny
            jmp loop

        exit:
            Pop  CharScreen.Character
        rts
    
        xWrite: .byte 0
    }

    /* Peek the value at location x,y, return character __val0 and color __val1 */
    Read: {
        .var x = __arg0
        .var y = __arg1
        .var screenLO = __tmp0 
        .var screenHI = __tmp1

        Push __tmp0; Push __tmp1

        ldy x
        ldx y

        clc
        lda screenRow.lo,x  
        sta screenLO

        lda screenRow.hi,x
        ora #$04 
        sta screenHI

        lda (screenLO),y  
        sta __val0

        // color
        lda screenRow.hi,x
        ora #$D8 
        sta screenHI

        lda (screenLO),y  
        sta __val1

        Pop __tmp1; Pop __tmp0
        
        rts
    }

    /* Plot a point, __arg0 is x 0..39, __arg1 is y 0..24 */
    Plot: {
        .var x = __arg0
        .var y = __arg1
        .var screenLO = __tmp0 
        .var screenHI = __tmp1

        Call _checkBounds:x:y
        lda __val0
        cmp #ACTION_HANDLED
        bne !+
            rts
        !:

        // screenLo/HI must be zp vector
        Push __tmp0; Push __tmp1

        // annoyingly backwards "x is Y" due to indirect indexing below
        ldy x
        ldx y

        clc
        lda screenRow.lo,x  
        sta screenLO

        lda screenRow.hi,x
        ora #$04 
        sta screenHI

        lda Character
        sta (screenLO),y  

        // set color ram
        lda screenRow.hi,x
        // ora is nice then to set the memory page
        ora #$D8 
        sta screenHI

        lda PenColor
        sta (screenLO),y  

        // restore
        Pop __tmp1; Pop __tmp0

        rts
    }

    /* Plot a hires sixel point, __arg0 is x 0..79, __arg1 is y 0..49 */
    PlotH: {
        .var x = __arg0
        .var y = __arg1
        
        // set sixel1 as default even
        Set sixel1:#1
        Set sixel0:#0

        // convert screen space
        lda x
        lsr 
        sta xScreen

        lda y
        lsr 
        sta yScreen

        // get current sixel
        Call CharScreen.Read:xScreen:yScreen
        // convert the character to the sixel index
        lda __val0
        ldx #0
        loop:
            cmp sixels,X
            bne !+
                stx sixel0
                jmp !next+
            !:
                inx
                cpx #16
                bne loop
        !next:

        // calulate new bit to set from odd/even of x,y
        lda x
        and #%00000001
        cmp #0
        beq !+ // was even, that's the default, do nothing
            // was odd, 
            Set sixel1:#2
        !:
        
        lda y
        and #%00000001
        cmp #0
        beq !+ // was odd, do nothing
            // was even, shift << 2
            lda sixel1
            asl;asl
            sta sixel1
        !:

        // sixel1 and sixel0 now have equivalent basis, 0..15
        // combine the two with OR so as to preserve any ON bits
        lda sixel0
        ora sixel1
        tax
        stx sixel1

        // lookup new char
        lda sixels,X
        sta sixel1

        // and plot
        Set CharScreen.Character:sixel1
        Call CharScreen.Plot:xScreen:yScreen

        rts
        xScreen: .byte 0
        yScreen: .byte 0
        //            20,7e, 7c, e2, 7b, 61,ff, ec, 6c, 7f, e1, fb, 62,fc, fe, a0
        sixels: .byte 32,126,124,226,123,97,255,236,108,127,225,251,98,252,254,160
        sixel0: .byte 0
        sixel1: .byte 0

    }

    /* PlotLine from x0,y0 to x1,y1 */
    PlotLine: {
        .var x0 = __arg0
        .var y0 = __arg1
        .var x1 = __arg2
        .var y1 = __arg3

        Set __ptr0:#<(CharScreen.Plot)
        Set __ptr0+1:#>(CharScreen.Plot)

        Call CastRay:x0:y0:x1:y1

        rts
    }

    /* Plot hires line from x0,y0 to x1,y1 */
    PlotLineH: {
        .var x0 = __arg0
        .var y0 = __arg1
        .var x1 = __arg2
        .var y1 = __arg3

        Set __ptr0:#<(CharScreen.PlotH)
        Set __ptr0+1:#>(CharScreen.PlotH)

        Call CastRay:x0:y0:x1:y1

        rts
    }

    /* Cast a ray from (x0,y0) to (x1,y1). Set __ptr0 to the action:x:y for processing:
        
        e.g. Plot:x:y
        - Set __ptr0:#<(CharScreen.Plot)
        - Set __ptr0+1:#>(CharScreen.Plot)

        action might be:
        - plot
        - read
        - save (in a queue or somewhere)
        - collide?
        - ?????

        Action must return #ACTION_HANDLED or #0
    */
    CastRay: {
        .var x0 = __arg0
        .var y0 = __arg1
        .var x1 = __arg2
        .var y1 = __arg3
        .var action = __ptr0

        Set e2:#0
        Set e2+1:#0

        // sx = x0 < x1 ? 1 : -1  // sign
        Set sx:#1
        lda x0
        cmp x1
        bcc !+
            Set sx:#-1
        !:

        // sy = y0 < y1 ? 1 : -1
        Set sy:#1
        lda y0
        cmp y1
        bcc !+
            Set sy:#-1
        !:

        Set xPrevious:x0
        Set yPrevious:y0

        lda y0
        cmp y1
        bne !skip+
            xloop:
                Call (action): x0: y0: xPrevious: yPrevious
                Set xPrevious:x0
                Set yPrevious:y0
                // if action returns #ACTION_HANDLED then exit/rts
                lda __val0
                cmp #ACTION_HANDLED
                bne !+
                    rts
                !:

                lda x0
                cmp x1
                bne !+
                    rts
                !:

                lda sx
                cmp #1
                bne !else+
                    inc x0
                    jmp xloop
                !else:
                    dec x0
                
            jmp xloop
        !skip:

        // optimzed horizontal
        lda x0
        cmp x1
        bne !skip+
            yloop:
                Call (action): x0: y0: xPrevious: yPrevious
                Set xPrevious:x0
                Set yPrevious:y0

                lda __val0
                cmp #ACTION_HANDLED
                bne !+
                    rts
                !:
                
                lda y0
                cmp y1
                bne !+
                    rts
                !:

                lda sy
                cmp #1
                bne !else+
                    inc y0
                    jmp yloop
                !else:
                    dec y0
            jmp yloop
        !skip:

        // the wikipedia algorithm
        // https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#All_cases
        /*
        dx = abs(x1 - x0)
        sx = x0 < x1 ? 1 : -1  // sign
        dy = -abs(y1 - y0)
        sy = y0 < y1 ? 1 : -1
        error = dx + dy
        
        while true
            plot(x0, y0)
            if x0 == x1 && y0 == y1 break
            e2 = 2 * error
            if e2 >= dy
                if x0 == x1 break
                error = error + dy
                x0 = x0 + sx
            end if
            if e2 <= dx
                if y0 == y1 break
                error = error + dx
                y0 = y0 + sy
            end if
        end while
        */

        // dx = abs(x1 - x0)
        // x1 - x0
        lda x1
        sec
        sbc x0
        // if .A is +ve then skip to just store the result
        // otherwise negate to get absolute value
        bpl !+
            // otherwise invert
            NegateA()
        !:
        sta dx

        // dy = -abs(y1 - y0)
        lda y1
        sec
        sbc y0
        bpl !+
            NegateA()
        !:
        // skip if zero
        cmp #0
        beq !+
            NegateA()
        !:
        sta dy

        // error = dx + dy
        lda dx
        clc
        adc dy
        sta error

        // while true
        loop:
            // plot(x0, y0)
            Call (action): x0: y0: xPrevious: yPrevious
            Set xPrevious:x0
            Set yPrevious:y0
            // if action returns #ACTION_HANDLED then exit/rts
            lda __val0
            cmp #ACTION_HANDLED
            bne !+
                rts
            !:

            // if x0 == x1 && y0 == y1 break
            lda x0
            cmp x1
            bne !+
                lda y0
                cmp y1
                bne !+
                    rts
            !:

            // e2 = 2 * error
            lda error
            asl 
            sta e2

            // if e2 >= dy
            lda e2
            cmp dy
            // signed CMP
            bmi skipX
                // if x0 == x1 break
                lda x0
                cmp x1
                bne !+
                    rts
                !:
 
                // error = error + dy
                lda error
                clc
                adc dy
                sta error

                // x0 = x0 + sx
                lda x0
                clc
                adc sx
                sta x0

            skipX: // end if

            // if e2 <= dx
            lda e2
            cmp dx
            bpl skipY
                // if y0 == y1 break
                lda y0
                cmp y1
                bne !+
                    rts
                !:

                // error = error + dx
                lda error
                clc
                adc dx
                sta error

                // y0 = y0 + sy
                lda y0
                clc
                adc sy
                sta y0
                
            skipY: // end if
        // end while
        jmp loop

        exit: rts

        // locals
        sx: .byte 0 
        sy: .byte 0 
        dx: .byte 0 
        dy: .byte 0 
        error: .byte 0
        e2: .byte 0
        xPrevious: .byte 0
        yPrevious: .byte 0
    }

    /* Draw a rectangle bound by point1 (x0,y0) to point2 (x1,y1) */
    PlotRect: {
        Set x0:__arg0
        Set y0:__arg1
        Set x1:__arg2
        Set y1:__arg3

        Call PlotLine:x0:y0:x1:y0
        Call PlotLine:x1:y0:x1:y1
        Call PlotLine:x1:y1:x0:y1
        Call PlotLine:x0:y1:x0:y0
        rts
        // the stack get's messed up, or maybe because I use a value multiple times
        // in a call, at any rate, getting some unexpected mutations, taking a copy solves this.
        x0: .byte 0
        y0: .byte 0
        x1: .byte 0
        y1: .byte 0
    }

    PlotRectH: {
        Set x0:__arg0
        Set y0:__arg1
        Set x1:__arg2
        Set y1:__arg3

        Call PlotLineH:x0:y0:x1:y0
        Call PlotLineH:x1:y0:x1:y1
        Call PlotLineH:x1:y1:x0:y1
        Call PlotLineH:x0:y1:x0:y0
        rts
        // the stack get's messed up, or maybe because I use a value multiple times
        // in a call, at any rate, getting some unexpected mutations, taking a copy solves this.
        x0: .byte 0
        y0: .byte 0
        x1: .byte 0
        y1: .byte 0
    }

    _checkBounds: {
        .var x = __arg0
        .var y = __arg1

        Set __val0:#0

        lda x
        cmp #39
        bcc !+
        beq !+
            Set __val0:#$ff
            rts
        !:

        lda y
        cmp #24
        bcc !+
        beq !+
            Set __val0:#$ff
            rts
        !:

        rts
    }

    screenRow: .lohifill 25, 40*i
}

